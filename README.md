# guard

Однопоточный header-only кроссплатформенный тестовый фреймворк, по синтаксису близок к облегчённому doctest. Требуется C++11+.

## Минимальный пример

```cpp
#include "guard.h"
#include <stdexcept>

TEST_CASE("simple arithmetic") {
    CHECK_EQ(2 + 2, 4);
    CHECK_LT(1, 10);
}

GUARD_TEST_MAIN();
```

Примеры использования смотрите в документации doctest — синтаксис и семантика максимально похожи.

---

## API

### Объявление тестов и запуск

- `TEST_CASE("name")` — объявляет и регистрирует тест с указанным именем.
- `GUARD_TEST_MAIN()` — генерирует `main` и запускает все зарегистрированные тесты. Поддерживает фильтр по подстроке имени теста: `--test-case=Substring` или `--test-case Substring`.
- `guard::test::run_all(const char *test_filter = nullptr, std::ostream &os = std::cout)` — низкоуровневый запускатель тестов (альтернатива `GUARD_TEST_MAIN`).

### Макросы проверок (алиасы, включены по умолчанию)

Мягкие (soft, не рвут тест, только копят ошибки):

- `CHECK(expr)`
- `CHECK_FALSE(expr)`
- `CHECK_EQ(a, b)` — ожидание `a == b`
- `CHECK_NEQ(a, b)` — ожидание `a != b`
- `CHECK_LT(a, b)` — ожидание `a < b`
- `CHECK_GT(a, b)` — ожидание `a > b`

Жёсткие (hard, немедленно останавливают текущий тест):

- `REQUIRE(expr)`
- `REQUIRE_FALSE(expr)`
- `REQUIRE_EQ(a, b)`
- `REQUIRE_NEQ(a, b)`
- `REQUIRE_LT(a, b)`
- `REQUIRE_GT(a, b)`

Для сравнительных макросов в сообщении об ошибке указываются файл/строка/функция, исходное выражение и значения левой и правой части (через `operator<<`).

### Исключения

Все проверки ниже фатальные: при нарушении ожиданий текущий тест сразу завершается.

- `CHECK_THROWS(code)` — ожидается любое исключение.
- `CHECK_THROWS_AS(code, ExType)` — ожидается исключение типа `ExType`.
- `CHECK_NOTHROW(code)` — ожидается отсутствие исключений.

### Таймаут

- `CHECK_TIMEOUT(code, ms)` — выполняет `code`, измеряет длительность, сравнивает с лимитом `ms` (миллисекунды). При превышении лимита — фатальный провал с отчётом о фактическом времени.

### Явный провал

- `FAIL(message)` — помечает тест как проваленный с указанным сообщением и немедленно его завершает.

### Приближённые сравнения

Класс `guard::Approx` (из `util.h`) для сравнения чисел с допуском:

- `Approx(double value)` — целевое значение.
- `Approx& epsilon(double eps)` — относительная погрешность.
- `Approx& scale(double s)` — масштаб (аналогично doctest/Catch2).
- `Approx operator()(double value) const` — создание копии с новым значением.

Поддерживаются сравнения: `x == Approx(...)`, `Approx(...) == x`, `x != Approx(...)`, `Approx(...) != x`. Числа считаются равными, если модуль разницы не превосходит рассчитанного допуска.

### Конфигурация алиасов

По умолчанию `guard.h` объявляет макросы:

- `CHECK`, `CHECK_FALSE`, `CHECK_EQ`, `CHECK_NEQ`, `CHECK_LT`, `CHECK_GT`
- `REQUIRE`, `REQUIRE_FALSE`, `REQUIRE_EQ`, `REQUIRE_NEQ`, `REQUIRE_LT`, `REQUIRE_GT`
- `FAIL`

Если нужны только низкоуровневые `GUARD_*`-макросы без алиасов:

```cpp
#define GUARD_TEST_NO_CHECK_ALIASES
#include "guard.h"
```

Тогда используются только `GUARD_CHECK`, `GUARD_REQUIRE` и т.п.

### Низкоуровневый API

Макросы проверок (когда алиасы отключены):

- `GUARD_CHECK(expr)` / `GUARD_REQUIRE(expr)`
- `GUARD_CHECK_FALSE(expr)` / `GUARD_REQUIRE_FALSE(expr)`
- `GUARD_CHECK_EQ(a, b)` / `GUARD_REQUIRE_EQ(a, b)`
- `GUARD_CHECK_NEQ(a, b)` / `GUARD_REQUIRE_NEQ(a, b)`
- `GUARD_CHECK_LT(a, b)` / `GUARD_REQUIRE_LT(a, b)`
- `GUARD_CHECK_GT(a, b)` / `GUARD_REQUIRE_GT(a, b)`

Служебные макросы и функции для интеграции (обычно не нужны пользователю): управление окружением проверки (start/error handler, добавление/установка сообщения, принудительный выход из теста); макросы для форматирования текущего места (файл/строка/функция); макросы для склейки и строкизации идентификаторов.

---

## Внутреннее устройство (коротко)

1. **Объявление тестов**: каждый `TEST_CASE` разворачивается в функцию и автоматику регистрации, которая добавляет тест в глобальный список при старте программы.
2. **Запуск**: раннер проходит по списку тестов (с учётом фильтра по имени) и последовательно запускает каждый, печатая статус и сводную статистику.
3. **Контроль выполнения**: каждый `TEST_CASE` выполняется внутри защищённого блока на внутренних исключениях — мягкие проверки копят сообщения, жёсткие бросают специальное исключение и прерывают тест, а раннер ловит его и печатает накопленные ошибки.
4. **Ошибки и сообщения**: все сообщения по тесту собираются в одну строку; по окончании она либо пуста (успех), либо печатается целиком (провал). Неожиданные исключения также переводятся в понятные текстовые ошибки.
5. **Портируемость**: используется только стандартный C/C++ (без потоков и платформенных API), поэтому код собирается везде, где есть нормальный компилятор C++11.
