````markdown
Headers-only кроссплатформенная тестовая система подделывающаяся под облегчённый doctest.
Стандарт C++11 и выше.

## Минимальный пример

```cpp
#include "guard.h"
#include <stdexcept>

TEST_CASE("simple arithmetic")
{
    CHECK_EQ(2 + 2, 4);
    CHECK_LT(1, 10);
}

GUARD_TEST_MAIN();
````

Примеры использования смотрите в документации doctest — синтаксис и семантика максимально похожи.

---

## API (application programming interface, программный интерфейс)

### Объявление тестов и запуск

* `TEST_CASE("name")`
  Объявляет и регистрирует тест с указанным именем.

* `GUARD_TEST_MAIN()`
  Генерирует `main` и запускает все зарегистрированные тесты.
  Поддерживает фильтр по подстроке имени теста:

  * `--test-case=Substring`
  * `--test-case Substring`

* `guard::test::run_all(const char* test_filter = nullptr, std::ostream& os = std::cout)`
  Низкоуровневый запускатель тестов (можно использовать вместо `GUARD_TEST_MAIN`).

---

### Макросы проверок (алиасы, включены по умолчанию)

Мягкие (soft, не рвут тест, только копят ошибки):

* `CHECK(expr)`
* `CHECK_FALSE(expr)`
* `CHECK_EQ(a, b)`    — ожидание `a == b`
* `CHECK_NEQ(a, b)`   — ожидание `a != b`
* `CHECK_LT(a, b)`    — ожидание `a <  b`
* `CHECK_GT(a, b)`    — ожидание `a >  b`

Жёсткие (hard, немедленно останавливают текущий тест):

* `REQUIRE(expr)`
* `REQUIRE_FALSE(expr)`
* `REQUIRE_EQ(a, b)`
* `REQUIRE_NEQ(a, b)`
* `REQUIRE_LT(a, b)`
* `REQUIRE_GT(a, b)`

Для сравнительных макросов в сообщении об ошибке указывается:

* файл, строка, функция;
* исходное выражение;
* значения левой и правой части (через `operator<<`).

---

### Исключения

(все фатальные: при нарушении ожиданий текущий тест сразу завершается)

* `CHECK_THROWS(code)`
  Ожидается любое исключение.

* `CHECK_THROWS_AS(code, ExType)`
  Ожидается исключение типа `ExType`.

* `CHECK_NOTHROW(code)`
  Ожидается отсутствие исключений.

---

### Таймаут

* `CHECK_TIMEOUT(code, ms)`
  Выполняет `code`, измеряет длительность, сравнивает с лимитом `ms` (миллисекунды).
  При превышении лимита — фатальный провал с отчётом о фактическом времени.

---

### Явный провал

* `FAIL(message)`
  Принудительно помечает тест как проваленный с указанным сообщением и немедленно его завершает.

---

### Приближённые сравнения

Класс `guard::Approx` (из `util.h`) для сравнения чисел с допуском:

* `Approx(double value)` — целевое значение.
* `Approx& epsilon(double eps)` — относительная погрешность.
* `Approx& scale(double s)` — масштаб (аналогично doctest/Catch2).
* `Approx operator()(double value) const` — создание копии с новым значением.

Поддерживаются сравнения:

* `x == Approx(...)`
* `Approx(...) == x`
* `x != Approx(...)`
* `Approx(...) != x`

Логика сравнения: число считается равным, если модуль разницы не превосходит рассчитанного допуска.

---

### Конфигурация алиасов

По умолчанию подключение `guard.h` объявляет макросы:

* `CHECK`, `CHECK_FALSE`, `CHECK_EQ`, `CHECK_NEQ`, `CHECK_LT`, `CHECK_GT`
* `REQUIRE`, `REQUIRE_FALSE`, `REQUIRE_EQ`, `REQUIRE_NEQ`, `REQUIRE_LT`, `REQUIRE_GT`
* `FAIL`

Если нужны только низкоуровневые `GUARD_*`-макросы без алиасов:

```cpp
#define GUARD_TEST_NO_CHECK_ALIASES
#include "guard.h"
```

Тогда используются только `GUARD_CHECK`, `GUARD_REQUIRE` и т.п.

---

### Низкоуровневый API

Макросы проверок (если алиасы отключены):

* `GUARD_CHECK(expr)`
* `GUARD_REQUIRE(expr)`
* `GUARD_CHECK_FALSE(expr)`
* `GUARD_REQUIRE_FALSE(expr)`
* `GUARD_CHECK_EQ(a, b)`
* `GUARD_REQUIRE_EQ(a, b)`
* `GUARD_CHECK_NEQ(a, b)`
* `GUARD_REQUIRE_NEQ(a, b)`
* `GUARD_CHECK_LT(a, b)`
* `GUARD_REQUIRE_LT(a, b)`
* `GUARD_CHECK_GT(a, b)`
* `GUARD_REQUIRE_GT(a, b)`

Служебные макросы и функции для интеграции (обычно не нужны пользователю):

* управление «окружением» проверки (start/error handler, добавление/установка сообщения об ошибке, принудительный выход из теста);
* макросы для форматирования строки с текущим местом (`файл/строка/функция`);
* макросы для склейки и строкизации идентификаторов.

---

## Внутреннее устройство (коротко)

1. **Объявление тестов**
   Каждый `TEST_CASE` разворачивается в обычную функцию и автоматику регистрации, которая добавляет тест в глобальный список при старте программы.

2. **Запуск**
   Раннер проходит по списку тестов, учитывая опциональный фильтр по имени, и последовательно запускает каждый тест, печатая статус и сводную статистику.

3. **Контроль выполнения**
    Каждый `TEST_CASE` выполняется внутри защищённого блока, построенного на внутренних исключениях:
    мягкие проверки только копят сообщения, жёсткие — бросают специальное исключение и мгновенно прерывают тест, а раннер ловит его и печатает накопленные ошибки.

4. **Ошибки и сообщения**
   Все сообщения по тесту собираются в одну строку; по окончании теста она либо пуста (успех), либо печатается целиком (провал). В эту же систему попадают «неожиданные» исключения, превращаясь в понятные текстовые ошибки.

5. **Портируемость**
   Внутри используется только стандартный C/C++ (без потоков, без платформенных API), поэтому код должен собираться везде, где есть нормальный компилятор C++11.

```
